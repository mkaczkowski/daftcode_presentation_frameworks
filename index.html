<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/daftcode.css">
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <script>
      var link = document.createElement("link")
      link.rel = "stylesheet"
      link.type = "text/css"
      link.href = window.location.search.match(/print-pdf/gi) ? "css/print/pdf.css" : "css/print/paper.css"
      document.getElementsByTagName("head")[0].appendChild(link)
    </script>
</head>
<body>
<header>
    <img src="https://daftcode.pl/static/pes-frame.a5436499.gif">
    <img src="https://daftcode.pl/static/text.741d3496.svg">
</header>

<div class="reveal">
    <div class="slides">

        <!--INTRO-->
        <section data-markdown class="intro">
        <textarea data-template>
        ![Img](/img/baner.png) <!-- .element height="90%" width="90%" -->
           - Asynchronous JS <!-- .element: class="h4" -->
           - & Fetch API <!-- .element: class="h5" -->
           - Mariusz Kaczkowski <!-- .element: class="author" -->
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>

        ## Sync vs Async
        <div class="my-container">
        ![Img](http://www.phpmind.com/blog/wp-content/uploads/2017/05/synchronous-asynchronous-javascript.png)
        </div>

        Note:
        Synchronous way: It waits for each operation to complete, after that only it executes the next operation.
        For your query: The console.log() command will not be executed until & unless the query has finished executing to get all the result from Database.

        Asynchronous way: It never waits for each operation to complete, rather it executes all operations in the first GO only.
        The result of each operation will be handled once the result is available. For your query: The console.log()
        command will be executed soon after the Database.Query() method. Whilegf the Database query runs in the background and loads the result
        once it is finished retrieving the data.

        Use cases
        If your operations are not doing very heavy lifting like querying huge data from DB then go ahead with Synchronous way otherwise Asynchronous way.
        In Asynchronous way you can show some Progress indicator to the user while in background you can continue with your heavy weight works. This is an ideal scenario for GUI apps.
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ### JS Engine

        ![Img](/img/event_loop.png)  <!-- .element height="55%" width="55%" -->

        Note:
        link do YT video !
        Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014
        https://www.youtube.com/watch?v=8aGhZQkoFbQ
        </textarea>
        </section>

        <section data-markdown>
            <textarea data-template>
            ## Async techniques
            * Callbacks
            * Promises
            * Async / Await
            * Generators*
            </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Callback ➡ call you back later

        ![Img](/img/callback.png)

        Note:
        Callbacks are just the name of a convention for using JavaScript functions. There isn't a special thing called a
        'callback' in the JavaScript language, it's just a convention. Instead of immediately returning some result like most
        functions, functions that use callbacks take some time to produce a result. The word 'asynchronous', aka 'async' just means
        'takes some time' or 'happens in the future, not right now'.

        Note that the handlePhoto is not invoked yet, it is just created and passed as a callback into downloadPhoto.
        But it won't run until downloadPhoto finishes doing its task, which could take a long time depending on how fast the Internet connection is.
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Callback Hell

        ![Img](/img/callback_hell.png)  <!-- .element height="75%" width="75%" -->

        Note:
        Each function gets an argument which is another function that is called with a parameter that is the response of the previous action.

        Callback hell is caused by poor coding practices. Luckily writing better code isn't that hard!
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Callback Hell
        <p style="font-style: italic">"Write small modules that each do one thing, and assemble them into other modules that do a bigger thing. You can't get into callback hell if you don't go there."</p>
        Isaac Schlueter
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Promise

        ![Img](/img/promise-catch.png) <!-- .element height="60%" width="60%" -->

        * pending
        * fulfilled
        * rejected

        Note:

        Status:
        : initial state, neither fulfilled nor rejected.
        : meaning that the operation completed successfully.
        : meaning that the operation failed.


        Many of us have already used promises in the form of libraries such as Q, when.js, RSVP.js, $.deffer, bluebird
        Even jQuery has something called a Deferred object, which is similar to a promise. But now we have native support for promises in JavaScript, which is really exciting.

        A Promise object represents a value that may not be available yet, but will be resolved at some point in the future.
        It allows you to write asynchronous code in a more synchronous fashion. For example, if you use the promise API to make an asynchronous
        call to a remote web service, you will create a Promise object which represents the data that will be returned by the web service in future.
        The caveat is that the actual data isn’t available yet. It will become available when the request completes and a response comes back from the web service.
        In the meantime, the Promise object acts like a proxy to the actual data.
        Furthermore, you can attach callbacks to the Promise object, which will be called once the actual data is available.

        In case of an error, reject() is called with an Error object. This indicates that the promise is rejected.


        </textarea>
        </section>


        <section data-markdown>
        <textarea data-template>
        ## Promise - Sample
        ![Img](/img/promise.png)
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Promise
        <div class="my-container">
        ![Img](/img/Creating-Promises.png)
        </div>
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Promise - Handling error
        ![Img](/img/promise_error.png)  <!-- .element height="75%" width="75%" -->
        </textarea>
        </section>


        <section data-markdown>
        <textarea data-template>
        ## Promise - Flow
        <div class="my-container">
        ![Img](/img/Chaining-Copy-1.png)
        </div>
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Chaining Promises

        ![Img](/img/promise_return.png)

        Note:
        The tricky part is that, when you return a simple value inside then(), the next then() is called with that return value.
        But if you return a promise inside then(), the next then() waits on it and gets called when that promise is settled.
        </textarea>
        </section>


        <section data-markdown>
        <textarea data-template>
        ## Promise utils
        ![Img](/img/promise_utils.png)
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Promise.all
        ![Img](/img/promise_all.png)
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Promise.race
        ![Img](/img/race.png)
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Promise - example
        ![Img](/img/promise_sample.png)
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## async / await

        ![Img](/img/async_await.png)

        Note:
        ES7 feature - babel
        The resulting code is much cleaner.
        Error handling is much simpler and it relies on try/catch just like in any other synchronous code.
        Debugging is much simpler. Setting a breakpoint inside a .then block will not move to the next .then
        with debugger you can step through await calls as if they were synchronous calls.

        > an Async Function always returns a Promise
        </textarea>
        </section>


        <section data-markdown>
        <textarea data-template>
        ## async / await - errors
        ![Img](/img/async_error.png)
        </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## async / await - sample
        ![Img](/img/async_sample.png)
        </textarea>
        </section>

        <section data-markdown>
            <textarea data-template>
                ## async / await bonus 🚀
                ![Img](/img/async_all.png)
            </textarea>
        </section>

        <section data-markdown>
        <textarea data-template>
        ## Client ↔ Server
        <div class="my-container2">
        ![Img](/img/API.png)  <!-- .element height="70%" width="70%" -->
            Note:
                1. odpalic w przegladarce:
                https://api.github.com/users/mkaczkowski

                2. Konsola + Network
                https://github.com/mkaczkowski/daftcode-react-starter
                opowiedziec o Cookies?
        </div>
        </textarea>
        </section>

        <section data-markdown>
            <textarea data-template>
                ## Before Fetch API
                ![Img](/img/fetch_1.png)
          </textarea>
        </section>

        <section data-markdown>
            <textarea data-template>
                ## Before Fetch API
                ![Img](/img/fetch_2.png)
      </textarea>
        </section>

        <section data-markdown>
            <textarea data-template>
                ## Fetch API
                ![Img](/img/fetch_3.png)

                Note:
                fetch() allows you to make network requests similar to XMLHttpRequest (XHR).
                The main difference is that the Fetch API uses Promises, which enables a simpler and cleaner API,
                avoiding callback hell and having to remember the complex API of XMLHttpRequest.

                The response of a fetch() request is a Stream object, which means that when we call the json() method,
                a Promise is returned since the reading of the stream will happen asynchronously.

                !!POKAZAC przyklad w przegladarce z fetch() bo dzala ;) !!
                fetch("https://api.github.com/users/mkaczkowski")
                fetch("https://api.github.com/users/mkaczkowski").then(response => console.info(response))
                fetch("https://api.github.com/users/mkaczkowski").then(response => response.json()).then(data => console.info(data))
      </textarea>
        </section>



        <section data-markdown>
            <textarea data-template>
                ## Fetch - Response

                ![Img](/img/fetch_response.png)

                Note:
                >When a request is made for a resource on the same origin, the response will have a basic type and there aren't any restrictions on what you can view from the response.
                If a request is made for a resource on another origin which returns the CORs headers, then the type is cors.
                >cors and basic responses are almost identical except that a cors response restricts the headers you can view
                >An opaque response is for a request made for a resource on a different origin that doesn't return CORS headers.
                With an opaque response we won't be able to read the data returned or view the status of the request, meaning we can't check if the request was successful or not.
                >no-cors is intended to make requests to other origins that do not have CORS headers and result in an opaque response, but as stated, this isn't possible in the window global scope at the moment.

            </textarea>
        </section>


        <section>
            <div class="container">
                <div class="col_code">
                    <div data-markdown>
                        ## Fetch - options
                        ![Img](/img/fetch_options.png)

                        Note:

                        await fetch("https://api.github.com/users/mkaczkowski")

                        At the moment there is no way to cancel a fetch,

                        Here, I choose to use Promise.reject because it's easier to implement.
                        Errors are cool too, but they're harder to implement, and the only benefit of an Error is a
                        stack trace, which would be non-existent in a Fetch request anyway.

                        The Promise returned from fetch() won’t reject on HTTP error status even if the response is an
                        HTTP 404 or 500. Instead, it will resolve normally (with ok status set to false), and it will
                        only reject on network failure or if anything prevented the request from completing.
                        By default, fetch won't send or receive any cookies from the server, resulting in
                        unauthenticated requests if the site relies on maintaining a user session (to send cookies, the
                        credentials init option must be set).

                        If you only want to send credentials if the request URL is on the same origin as the calling
                        script, add credentials: 'same-origin'.

                        Files can be uploaded using an HTML <input type="file"/> input element, FormData() and fetch().

                        redirect:
                        If it is "follow", fetch() API follows the redirect response (HTTP status code =
                        301,302,303,307,308).
                        If it is "error", fetch() API treats the redirect response as an error.
                        If it is "manual", fetch() API doesn't follow the redirect and returns an opaque-redirect
                        filtered response which wraps the redirect response.

                        “default” means use the default behavior of browsers when downloading resources. The browser
                        first looks inside the HTTP cache to see if there is a matching request. If there is, and it is
                        fresh, it will be returned from fetch(). If it exists but is stale, a conditional request is
                        made to the remote server and if the server indicates that the response has not changed, it will
                        be read from the HTTP cache. Otherwise it will be downloaded from the network, and the HTTP
                        cache will be updated with the new response.
                        “reload” means bypass the HTTP cache on the way to the network, but update it with the newly
                        downloaded response. This will cause the browser to never look inside the HTTP cache on the way
                        to the network, but update the HTTP cache with the downloaded response. Future requests can use
                        that updated response if appropriate.
                        “no-cache” means always validate a response that is in the HTTP cache even if the browser thinks
                        that it’s fresh. This will cause the browser to look for a matching request in the HTTP cache on
                        the way to the network. If such a request is found, the browser always creates a conditional
                        request to validate it even if it thinks that the response should be fresh. If a matching cached
                        entry is not found, a normal request will be made. After a response has been downloaded, the
                        HTTP cache will always be updated with that response.
                        “force-cache” means that the browser will always use a cached response if a matching entry is
                        found in the cache, ignoring the validity of the response. Thus even if a really old version of
                        the response is found in the cache, it will always be used without validation. If a matching
                        entry is not found in the cache, the browser will make a normal request, and will update the
                        HTTP cache with the downloaded response.
                    </div>
                </div>
                <div class="col_text">
                    <div data-markdown>
                        - method
                        - headers
                        - credetnails
                        - cache
                        - mode
                        - body
                        - redirect
                        - referrer
                    </div>
                </div>
            </div>
        </section>


        <section data-markdown>
            <textarea data-template>
                ## Fetch compatibility
                ![Img](/img/fetch_support.png)  <!-- .element height="60%" width="60%" -->

                #### Polyfills:
                   - whatwg-fetch [IE10+]
                   - wisomorphic-fetch
                   - fetch-ie8
            </textarea>
        </section>

        <section data-markdown>
            <textarea data-template style="text-align: left">
                ## Cookies 🍪 (IE 2 - 1995)

                <div style="display: inline-block; text-align: left">
                <div class="inline-section">
                #### Set-Cookie header (server):
                * Set-Cookie: yummy_cookie=choco
                * Domain=mydomain.com; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT
                </div>
                <div class="inline-section">
                #### Cookie HTTP header (client):
                * Cookie:yummy_cookie=choco
                </div>
    <div class="inline-section">
                #### JS
                * document.cookie = "tasty_cookie=strawberry";
                * console.log(document.cookie);
</div>
                    </div>
                Note:
                An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to the user's web browser.
                he browser may store it and send it back with the next request to the same server
                Typically, it's used to tell if two requests came from the same browser
                Cookies are sent with every request, so they can worsen performance (especially for mobile data connections).

                When receiving an HTTP request, a server can send a Set-Cookie header with the response. The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a Cookie HTTP header. An expiration date or duration can be specified, after which the cookie is no longer sent. Additionally, restrictions to a specific domain and path can be set, limiting where the cookie is sent.

                is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing.
                 Perhaps most importantly, authentication cookies are the most common method used by web servers to know whether the user is logged in or not, and which account they are logged in with

                 it is deleted when the client shuts down, because it didn't specify an Expires or Max-Age
                For example, if Domain=mozilla.org is set, then cookies are included on subdomains like developer.mozilla.org.

                Session management
                Logins, shopping carts, game scores, or anything else the server should remember
                Personalization
                User preferences, themes, and other settings
                Tracking
                Recording and analyzing user behavior
            </textarea>
        </section>


        <section data-markdown>
            <textarea data-template>
                ## Fetch - async / await
                ![Img](/img/fetch_async_await.png)

                Note:
                let response = await fetch("https://api.github.com/users/mkaczkowski")
                await response.json()
            </textarea>
        </section>

        <section data-markdown>
            <textarea data-template>
                ## Fetch - Axios
                ![Img](/img/axios.png) <!-- .element height="80%" width="80%" -->

                Note:
                In order to fix all my problem, i find Axios for my rescue. Axios is a Promise based HTTP client for the browser and node.js.
                Advantages of using Axios:
                1. Transformers: allow performing transforms on data before request is made or after response is received.
                2. Interceptors: allow you to alter the request or response entirely (headers as well). also perform async operations before request is made or before Promise settles.
                3. Built-in XSRF protection.
                4. Make XMLHttpRequests from the browser & http requests from node.js.
                5. Cancel requests and timeout feature.
                4.8kb
            </textarea>
        </section>

        <!-- TOOLS -->
        <!--POSTMAN-->
        <!--GET https://jsonplaceholder.typicode.com/posts/1-->
        <!--POST https://jsonplaceholder.typicode.com/posts-->

        <!-- LIVECODING -->
        <!--<section data-background-image="/img/cat.gif"></section>-->

        <!--END-->
        <section data-background-image="/img/thats-all-folks-gif-12.gif"></section>

        <!--LIVE CODING-->
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    controls: true,
    progress: false,
    touch: false,
    slideNumber: false,
    loop: true,
    mouseWheel: true,
    // defaultTiming:-1,
    // parallaxBackgroundImage: "https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg",
    dependencies: [
      {src: "plugin/markdown/marked.js"},
      {src: "plugin/markdown/markdown.js"},
      {src: 'plugin/zoom-js/zoom.js', async: true},
      {src: "plugin/notes/notes.js", async: true},
      {
        src: "plugin/highlight/highlight.js", async: true, callback: function () {
          hljs.initHighlightingOnLoad()
        },
      },
    ],
  })
</script>
</body>
</html>
