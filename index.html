<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/daftcode.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link")
      link.rel = "stylesheet"
      link.type = "text/css"
      link.href = window.location.search.match(/print-pdf/gi) ? "css/print/pdf.css" : "css/print/paper.css"
      document.getElementsByTagName("head")[0].appendChild(link)
    </script>
</head>
<body>
<header >
    <img src="https://daftcode.pl/static/pes-frame.a5436499.gif">
    <img src="https://daftcode.pl/static/text.741d3496.svg">
</header>

<div class="reveal">
    <div class="slides">

        <section data-background-image="http://gifimage.net/wp-content/uploads/2017/06/thats-all-folks-gif-12.gif">
        </section>

        <section data-markdown class="three">
            <script type="text/template">
                ### Co nam daje framework?
                - **Speed**: By using frameworks we deal with pre-build functions so that it helps to speed up the development process.
                - **Support**: A famous framework has huge community associated with it, that works as support team for you.
                - **Cost**: Most of the best frameworks are free to use, so cost can be cut on both developer and client ends.



                To build large apps with data changes over time

                Frameworks are designed for doing more complex things, so, if you are using framework, there is already solved lot’s of problems for you. Frameworks have predefined design, already setup task runners and many libraries. You already can create fully functional project without other setups. As a result we can setup a new project very easily, development process is much faster, because we are already using high level API’s and every application which developed with that framework use same libraries, so for other developers will be much easier to join. But frameworks have more strict design.

                Angular is a framework rather than a library because it provides strong opinions as to how your application should be structured and also has more functionality out of the box.

            </script>
        </section>


        <section data-markdown class="three">
            <script type="text/template">
                ![Frameworks](https://angular.io/assets/images/logos/angular/angular.png) <!-- .element: class="logo" -->
                ![Frameworks](https://upload.wikimedia.org/wikipedia/commons/f/f1/Vue.png) <!-- .element: class="logo" -->
                ![Frameworks](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/React-icon.svg/1280px-React-icon.svg.png) <!-- .element: class="logo" -->

                Of the three major players Angular has been around the longest by a sizeable margin. This gave the team at Google a long time to optimize and evolve the platform but resulted in a bloated, disjointed codebase. To tackle this problem Angular just went through a total, non-backwards-compatible rewrite from legacy JavaScript into TypeScript. This smoothed a lot of the rough edges, built a well-documented and typed API, and seriously improved performance. However, Angular tries to be everything to everyone – it ships with it’s own HTTP/AJAX module, it’s own animations implementation, form validation, routing, and so on. Some people like this since most full-featured UIs need many of these features and they all integrate well with one another, but other developers prefer to use libraries they’re familiar with and find it difficult to work around the built-ins. These extra features also add some serious weight to the framework – Angular deliverables are typically larger than competitors which is a concern in bandwidth-constrained environments.

                The Angular templates are enhanced HTML with special Angular language (Things like ngIf or ngFor). While React requires knowledge of JavaScript, Angular forces you to learn Angular-specific syntax.

                 - 2009

                 - ?? DOM
                -Two-way data binding
                - native script
                - mvc
                - angular-cli
                - google
                - typescript
                - routing, animation, form validation, etc
                - 143kkb
                - Jasmine or Karma + Mocha
                - OOP

                -------------------

                Controller
                While you can write Angular is ES5, most people use Typescript. Decorators are used heavily to add metadata to the code such as when declaring a component controller. This defines where to look for the view and style code and manages data and event logic.


                @Component({
                selector: 'counter',
                templateUrl: './counter.component.html',
                styleUrls: ['./counter.component.css']
                })
                export class CounterComponent {
                value: number = 0;

                increment(): void {
                value++;
                }
                }

                View
                <h2>Current value is {{ value }}</h2>
                <button>Increment</button>

                -------------------


                YOU MIGHT LIKE… | 	YOU MIGHT HATE…
                Type safety (TypeScript)	| Heavy platform
                Extensive feature set – Validation, AJAX, Animations, etc.	|  Performance
                Code separation	| Some awkward, unintuitive APIs

            </script>
        </section>

        <section data-markdown class="three">
            <script type="text/template">
                ### React

                React takes almost a total opposite approach to Angular – it is a very light framework with few helper modules which allows it to focus on being fast and easy to learn. In fact, the common quote you’ll hear is that knowing how to develop in React is 80% knowing JavaScript and 20% knowing React.

                One of the biggest differences in React is how it manages to get its speed – Angular and Vue do varying levels of change detection to automatically keep your code and view in-sync, but React requires the developer to notify it of changes that are worth rendering. This makes it very fast but also requires more work and micromanagement on the part of the implementor. As you move into more advanced React projects you’ll almost certainly end up using management libraries like Flux & Redux to handle more complex change detection and state management situations since it quickly becomes difficult to handle manually.

                Stylistically, React aims to keep code and view tightly intertwined – the view code is typically written in a mixed markup known as JSX. I personally don’t like interweaving my code that way but I see the advantage and could get used to it given time.

                 - 2013
                - Virtual DOM
                -  one-directional
                 -reactnative
                - Facebook
                - view layer
                - create-react-app
                - es6 / babel / typescript
                - flow
                - ecosystem
                - Facebook, Reddit, Airbnb, Netflix, and Google, Twitter, Reddit, Paypal.
                - easier to test;
                - 43kb
                - jsx
                Facebook uses Jest to tests its React code.
                - funcitonal progrmming


                Angular includes dependency injection, a pattern in which one object supplies the dependencies (a service) to another object (a client). This leads to more flexibility and cleaner code.

                -------------------
                export class Counter extends React.Component {
                render() {
                return <div>
                    <h2>Current value is { this.state.value }</h2>
                    <button>Increment</button>
                </div>
                }

                increment() {
                this.setState({
                value: this.state.value + 1
                });
                }
                }

                -------------------


                YOU MIGHT LIKE…	| YOU MIGHT HATE…
                Almost pure JavaScript	| JSX, some awkward syntax
                Lightweight	| Intermixed View, Style, and Logic code
                Brevity |	State management
                -------------------

                JSX implies that everything in React is Javascript — it is used for both the JSX templates and the logic.

            </script>
        </section>

        <section data-markdown class="three">
            <script type="text/template">
                ### Vue

                Vue is a relative newcomer. Those coming from Angular and React will see a lot that feels familiar – Vue shares the some of the same directive-based structures as Angular, while code organization is similar to React with intermixed view templates, logic, and styles. It also takes the approach of being a slim, targeted framework so unlike Angular there aren’t many extra modules, but it does keep a lot of the helpful elements like filter/pipe chains, one-time binding, and automatic change detection. The net result is a nicely-rounded framework that’ll do pretty much everything you need it to while being *crazy* fast. Overall, the impression I get of Vue is of an updated and streamlined Angular 1.x which is definitely not a bad thing.

                Vue is primarily developed by a single individual but has some corporate sponsors to pay the bills

                Vue features “single-file components”. This seems like a trade-off with regard to the separation of concerns — templates, scripts and styles are in one file but in three different, ordered sections.

                “Intuitive, Fast and Composable MVVM for building interactive interfaces.”


                -------------------
                 - 2014
                - es6 / es5
                - made by ex-Google-employee Evan You with sponsors
                - Virtual DOM
                 - framework
                - gitlab
                - weex
                - vue-cli
                - one-way and two-way data binding
                - active comunnity
                - 23kb
                - bit faster
                - convenient templates simplify the process of developing;
                - it is simpler in terms of syntax.
                - clean code

                -------------------

                <template>
                    <div>
                        <h2>Current value is {{ value }}</h2>
                        <button>Increment</button>
                    </div>
                </template>

                <!--<s cript>-->
                  const state = {
                    value: 0.0
                  };
                  const increment = () => {
                    state.value++;
                  };
                  export default {
                    name: 'counter',
                    data() {
                      return state;
                    },
                    methods: {
                      increment
                    }
                  }
            <!--</s cript>-->

            <style scoped>
                /*// Styles go here*/
            </style>

                -------------------

                YOU MIGHT LIKE…	YOU MIGHT HATE…
                Half-intermixed View, Style, and Logic code | 	Half-intermixed View, Style, and Logic code
                Lightweight	| Unintuitive attribute binding
                Framework support for filters, computed properties, transitions, etc. |	IDE support not great
                -------------------

            </script>
        </section>

        <section data-markdown class="sumup">
            <textarea data-template>
                #### Sum up
                React, Angular and Vue are all pretty cool, and none of them stands clearly above the others.

 Each makes compromises in order to achieve a chosen target – React supplies very few features in order to achieve speed and simplicity, Angular sacrifices speed and simplicity to provide lots of features and a rich development experience, and Vue comes in somewhere in the middle. Which one is right for you really ends up being a question of “how do you like to develop”? Your personal preferences and experience of your team are really the deciding factors.

                As we’d found out previously, many developers prefer Vue for creating small apps. But React is definitely better for larger apps developing. Why React.JS? It tends to be more flexible and adjustable. As we know, Vue uses templates, which makes the development process simpler and faster. But when an app is big, these benefits tend to turn into drawbacks. Often use of templates makes restructuring of an app impossible or too complicated. React’s code with JS templates is reusable, and when you create React app, you can easily restructure it in future.


                We said that popularity (We’ll check it later) is an issue when deciding but there are another things like “Big company based”, “Speed”, “Mature”, “Will it survive in 5 years?”, “Learning curve”, “Mobile”.

                Big company based — Angular/React
                Speed — All. React was built by facebook to handle their huge DOM updates. Angular and Vue are really fast either. so as long as you don’t build a rocket machine with your DOM, all of them are great choice. Facebook is one of the biggest SPA out there.
                Wsteczna kompatybilnosc: React (no break changes, codemons)
                Learning curve — React/Vue. (Redux is hard)  angular 2 is a monster if you want to do advanced things. for juniors it’s harder.
                Mobile — React. Definitely. after the era of hybrid apps, the world turning right now to a native apps. native apps always been here but you always needed an android developer + ios developer. now with react native you can learn react, then understand the differences between browser elements and mobile elements and you can start build your own native app.
                Angular has NativeScript but it’s not mature/popular as react native.

                And the winner is — REACT!
                Why? i think after everything i said, the most important thing is what will last in the next 5 years.
                So if the past says a big company framework based will live longer, than React/Angular should be the kings here and Vue might be some another framework out there like ember/backbone/knockout was.

                If you have in-house HTML developers who do not want to learn more Javascript, you are better off choosing Angular or Vue. React entails more Javascript (we talk about this later).

                Learn pure JS / ES6 first :D
            </textarea>
        </section>



        <section data-markdown class="intro">
            <textarea data-template>
               ![Frameworks](/img/baner.png)
               - Przegląd frameworków JS <!-- .element: class="h4" -->
               - dlaczego właśnie React? <!-- .element: class="h5" -->
               - Mariusz Kaczkowski <!-- .element: class="author" -->
            </textarea>
        </section>

        <section data-markdown class="three">
            <script type="text/template">
                #### Kiedyś
                ![Frameworks](/img/carbon1.png)
            </script>
        </section>

        <section data-markdown class="three">
            <script type="text/template">
                #### Dziś
                ![Frameworks](/img/carbon2.png)
            </script>
        </section>

        <section data-markdown class="three">
            <script type="text/template">
                #### package.json
                ![Frameworks](/img/code1.png)
                ![Frameworks](/img/code02.png)
                ![Frameworks2](/img/code03.png)
            </script>
        </section>

        <section data-markdown class="pop">
            <script type="text/template">
                #### Popularnośc (2017)
                Ankieta wśród programistów wg. [stateofjs.com](https://stateofjs.com/2017/front-end/results/)
                ![Frameworks](/img/frameworks_chart.png)
            </script>
        </section>

        <section data-markdown class="three">
            <script type="text/template">
                #### Wielka trójca
                ![Frameworks](/img/506.jpg)

                Note: We said that popularity (We’ll check it later) is an issue when deciding but there are another things like “Big company based”, “Speed”, “Mature”, “Will it survive in 5 years?”, “Learning curve”, “Mobile”.

                The frameworks in question are all component-based. A component gets an input, and after some internal behavior / computing, it returns a rendered UI template (a sign in / sign out area or a to-do list item) as output. The defined components should be easy to reuse on the webpage or within other components.
            </script>
        </section>

        <section data-markdown class="stars">
            <script type="text/template">
                #### Liczba ⭐ na Github
                ![Frameworks](/img/frameworks_stars.png)
            </script>
        </section>

        <section data-markdown class="stars">
            <script type="text/template">
                #### npm downloads
                ![Frameworks](/img/downloads.png)
            </script>
        </section>

        <section>
            ### REACT COMPONENTS
            - reusable
            - composable
            - self-contained
            - unit testable

            Note:  All logically separable parts of the code, like input field, a button, a form, a list etc. should be written in separate components.

            ![Frameworks](/img/component.png)

        </section>

        <section>
            JSX

            - create JS objects using HTML syntax
            JSX adds an XML-like syntax to JavaScript and makes creating ReactJS components easier. While not required, JSX adds enough benefits to be considered a standard part of React development.
            JSX provides a shortcut for working with React.createElement() and describes how the UI should render a component.
            JSX also improves development time
            JSX also forces safer coding. Before rendering elements, JSX converts everything to strings to escape user inputs and XSS vulnerabilities.

            ![Frameworks](/img/jsx.png)
            ![Frameworks](/img/jsx2.png)
            ![Frameworks](/img/jsx3.png)

        </section>


        <section>
            PROPS

            - immutable
            - Uni directional data flow

            props are the parameters passed to that function when it's called. Anything can be a prop: a string, boolean, number, some other React element, undefined...
            The most important thing to keep in mind about the props is that they are read-only, meaning that they can't be changed in the component receiving them and shouldn't be mutated.
            Props are like parameters - they are passed to a component from the caller of a component (the parent) : as if you called a function with certain parameters.

            ![Frameworks](/img/props.png)


        </section>

        <section>
            State

            - mutable

            The state is similar to attributes in object-oriented programming : it's something local to a class (component), used to better describe it. We'll cover React state management and what should be kept in the local state in another article.
            State, on the other hand, is private and its main purpose is to manipulate it within the component. The state is available only to classes, and is used to handle some internal changes (like updating some text stored based on onChange event):

            ![Frameworks](/img/state1.png)
            ![Frameworks](/img/state2.png)

            Note:
            The state is initialized in the constructor, a special method called before initial component render. All the custom methods (like handleChange in the previous example) should be written using arrow function, so they're automatically bound to a component.

            setState() also accepts a function. The function accepts the previous state and current props of the component which it uses to calculate and return the next state. See it below:
            Note that setState() is a function, and we are passing another function to it(functional programming… functional setState) . At first glance, this might seem ugly, too many steps just to set-state. Why will you ever want to do this?

            Think about what happens when setState() is called. React will first merge the object you passed to setState() into the current state. Then it will start that reconciliation thing. It will create a new React Element tree (an object representation of your UI), diff the new tree against the old tree, figure out what has changed based on the object you passed to setState() , then finally update the DOM.
            Because of the amount of work involved, calling setState() might not immediately update your state.

            Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.

            A key difference between state and props is that props are read-only. You can't change the value of a property from within the component itself. Properties are externally passed into components as configuration values and read within the components themselves.

        </section>

        <section data-markdown class="">
            <script type="text/template">
                ## React c.d. 1
                DOM stands for Document Object Model
                For web developers, this text is an HTML code, and the DOM is simply called HTML DOM. Elements of HTML become nodes in the DOM.

                document is an abstraction of the root node, while getElementById, parentNode and removeChild are methods from HTML DOM API.

                The HTML DOM is always tree-structured - which is allowed by the structure of HTML document. This is cool because we can traverse trees fairly easily. Unfortunately, easily doesn’t mean quickly here.
                The Document object model is a representation of the structure of all the node in a html document. It provides a way for javascript to interact with all every single node in a html document (it's essentially an API for html and xml documents).
                next, prev, parent, children,

                Virtual DOM is about avoiding unnecessary changes to the DOM, which are expensive performance-wise, because changes to the DOM usually cause re-rendering of the page. Virtual DOM also allows to collect several changes to be applied at once, so not every single change causes a re-render, but instead re-rendering only happens once after a set of changes was applied to the DOM.

                Virtual DOM is already in memory, on the other hand real DOM has to be accessed from page and loaded to memory for any operation.

                Wcześniej rerender whole app on every update - perf issue!
                Operations on DOM are slow

                ![Frameworks](/img/vdom.png)
            </script>
        </section>


        <section>
            ### Component Lifecycle
            Methods handling the component lifecycle are inherited from Component (yes, that Component you're importing at the top of the file). The most detailed description of lifecycle methods can be found here.

            ![Frameworks](/img/lifecycle.png)

            interactive diagram [pl]:
            http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
            <!--https://pbs.twimg.com/media/DZ-97vzW4AAbcZj.jpg:large-->
            <!--https://reactjs.org/docs/react-component.html-->

            ![Img](/img/lifeycle/compDidUpdate.png)
            ![Img](/img/lifeycle/componentDidMount.png)
            ![Img](/img/lifeycle/compWillUnmount.png)
            ![Img](/img/lifeycle/constructor.png)
            ![Img](/img/lifeycle/getDerived.png)
            ![Img](/img/lifeycle/getSnapshot.png)
            ![Img](/img/lifeycle/render.png)
            ![Img](/img/lifeycle/shouldCompUpdate.png)

        </section>

        <section data-background-image="https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg">Slide 1</section>

        <section>
        #HOMEWORK

        Należy stworzy komponent 'Counter', ktory w swoim dzialniu bedzie zblizony do minutnika.
        Powinien wyswietla w czasie rzeczywistym, co 1 sekunde, akutalny stan licznika.

         Komponent przyjmuje wartosci:
            wymagane:
                from: number [sec]
                to: number [sec]
            opcjonalne:
                onSuccess: function

         Rozpoczecie odliczania nastepuje automatycznie.
         Odliczanie od liczby podanej w [from], az  do osiagniecia liczby [to].
         W momencie osiagniecia wartosci [to] nalez wywolac funkcje/callback podana w [onSuccess] o ile ta istnieje.

         Dodatkowo  po kliknieciu w komponent nastapi zresetowanie licznika i ponowny start zaczynajac od wartosci [from].

         Dla Asów programowania:
         * PropTypes
         * format minutnika: mm:ss -> 00:59
         * jezeli timer nie doszedl do konca to klikniecie w komponent wstrzymuje timer, a kolejne klikniecie wznawia odliczanie.
         * dodanie dowolnych styli inline
        </section>

        <!--LIVE CODING-->
        <!--FRONTEND DEV ROADMAP-->
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    controls: false,
    progress: false,
    touch:false,
    slideNumber:false,
    // defaultTiming:-1,
    // parallaxBackgroundImage: "https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg",
    dependencies: [
      { src: "plugin/markdown/marked.js" },
      { src: "plugin/markdown/markdown.js" },
      { src: "plugin/notes/notes.js", async: true },
      {
        src: "plugin/highlight/highlight.js", async: true, callback: function() {
          hljs.initHighlightingOnLoad()
        },
      },
    ],
  })
</script>
</body>
</html>
