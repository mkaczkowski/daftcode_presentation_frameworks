<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/daftcode.css">
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <script>
        var link = document.createElement("link")
        link.rel = "stylesheet"
        link.type = "text/css"
        link.href = window.location.search.match(/print-pdf/gi) ? "css/print/pdf.css" : "css/print/paper.css"
        document.getElementsByTagName("head")[0].appendChild(link)
    </script>
</head>
<body>
<header>
    <img src="https://daftcode.pl/static/pes-frame.a5436499.gif">
    <img src="https://daftcode.pl/static/text.741d3496.svg">
</header>

<div class="reveal">
    <div class="slides">

        <!--INTRO-->
        <section data-markdown class="intro">
        <textarea data-template>
        ![Img](/img/baner.png)
         - JS Frameworks overview  <!-- .element: class="h4" -->
         - Let's try React! <!-- .element: class="h5" -->
         - Mariusz Kaczkowski <!-- .element: class="author" -->
        </textarea>
        </section>

        <!--OLD WAY-->
        <section data-markdown class="three">
            <script type="text/template">
                #### JQuery way
                ![Img](/img/carbon1.png)
            </script>
        </section>

        <!--MODERN WAY-->
        <section data-markdown class="three">
            <script type="text/template">
                #### Modern approach
                ![Img](/img/carbon2.png)
            </script>
        </section>

        <!--PACKAGE.JSON-->
        <section data-markdown class="three">
            <script type="text/template">
                #### package.json
                ![Img](/img/code1.png)
                ![Img](/img/code02.png)
                ![Frameworks2](/img/code03.png)
            </script>
        </section>

        <!--JACKIE CHAN-->
        <section data-background-image="/img/lee.png">
        </section>

        <!--FRAMEWORKS-->
        <section data-markdown class="three">
            <script type="text/template">
                ### When we really need it?
                To build large apps with data changes over time
                <br/>
                <br/>

                ### What we get with framework?
                * Development Speed <!-- .element: class="fragment" data-fragment-index="1" -->
                * Best practices <!-- .element: class="fragment" data-fragment-index="2" -->
                * Support <!-- .element: class="fragment" data-fragment-index="3" -->
                * Cost <!-- .element: class="fragment" data-fragment-index="4" -->


                Note:
                Frameworks are designed for doing more complex things, so, if you are using framework,
                there is already solved lot’s of problems for you. Frameworks have predefined design,
                already setup task runners and many libraries. You already can create fully functional
                project without other setups. As a result we can setup a new project very easily,
                development process is much faster, because we are already using high level API’s and
                every application which developed with that framework use same libraries, so for
                other developers will be much easier to join. But frameworks have more strict design.

                SPPED -  By using frameworks we deal with pre-build functions so that it helps to speed up the development process.
                BEST PRACTICES - Frameworks have already predefined, double checked and tested designs based on patterns
                SUPPORT -  famous framework has huge community associated with it, that works as support team for you.
                COST - Most of the best frameworks are free to use, so cost can be cut on both developer and client ends.
            </script>
        </section>

        <!--POPULARITY-->
        <section data-markdown class="pop">
            <script type="text/template">
                #### Popularity (2017)
                by programmers via [stateofjs.com](https://stateofjs.com/2017/front-end/results/)
                ![Img](/img/frameworks_chart.png)
            </script>
        </section>

        <!--FIGHT-->
        <section data-background-image="/img/506.jpg" data-transition="zoom">
        </section>

        <!--⭐-->
        <section data-markdown class="stars">
            <script type="text/template">
                #### Number of ⭐ on GitHub
                ![Img](/img/frameworks_stars.png)
            </script>
        </section>

        <!--DOWNLOADS-->
        <section data-markdown class="stars">
            <script type="text/template">
                #### NPM downloads
                ![Img](/img/downloads.png)
            </script>
        </section>

        <!--<section data-markdown class="three" data-transition="zoom">-->
            <!--<script type="text/template">-->
                <!--![Img](/img/506.jpg)-->
            <!--</script>-->
        <!--</section>-->

        <!--ANGULAR-->
        <section>
            <div class="container">
                <div class="col_code">
                    <div data-markdown>
                        ![Img](/img/angular.png)

                        Note:
                        Of the three major players Angular has been around the longest by a sizeable margin. This gave
                        the team at Google a long time to optimize and evolve the platform but resulted in a bloated,
                        disjointed codebase. To tackle this problem Angular just went through a total,
                        non-backwards-compatible rewrite from legacy JavaScript into TypeScript. This smoothed a lot of
                        the rough edges, built a well-documented and typed API, and seriously improved performance.
                        However, Angular tries to be everything to everyone – it ships with it’s own HTTP/AJAX module,
                        it’s own animations implementation, form validation, routing, and so on. Some people like this
                        since most full-featured UIs need many of these features and they all integrate well with one
                        another, but other developers prefer to use libraries they’re familiar with and find it
                        difficult to work around the built-ins. These extra features also add some serious weight to the
                        framework – Angular deliverables are typically larger than competitors which is a concern in
                        bandwidth-constrained environments.
                        The Angular templates are enhanced HTML with special Angular language (Things like ngIf or
                        ngFor). While React requires knowledge of JavaScript, Angular forces you to learn
                        Angular-specific syntax.
                        Angular2 has change detection that detects changes to the model and only updates the parts of
                        the DOM that need to be changed according to the model changes.
                        While you can write Angular is ES5, most people use Typescript. Decorators are used heavily to
                        add metadata to the code such as when declaring a component controller. This defines where to
                        look for the view and style code and manages data and event logic.
                        Framework: routing, animation, form validation, etc

                        YOU MIGHT LIKE… | YOU MIGHT HATE…
                        Type safety (TypeScript) | Heavy platform
                        Extensive feature set – Validation, AJAX, Animations, etc. | Performance
                        Code separation | Some awkward, unintuitive APIs
                    </div>
                </div>
                <div class="col_text">
                    <div data-markdown>
                        ![Img](/img/angular-2.png)
                        - 2009/2016 Google
                        - TypeScript (OOP)
                        - MVC
                        - Framework
                        - angular-cli
                        - NativeScript
                        - 143kb
                    </div>
                </div>
            </div>
        </section>

        <!--REACT-->
        <section>
            <div class="container">
                <div class="col_code">
                    <div data-markdown>
                        ![Img](/img/react.png)

                        Note:
                        - Facebook, Reddit, Airbnb, Netflix, and Google, Twitter, Reddit, Paypal.
                        Facebook uses Jest to tests its React code.
                        - funcitonal progrmming
                        React takes almost a total opposite approach to Angular – it is a very light framework with few
                        helper modules which allows it to focus on being fast and easy to learn. In fact, the common
                        quote you’ll hear is that knowing how to develop in React is 80% knowing JavaScript and 20%
                        knowing React.
                        One of the biggest differences in React is how it manages to get its speed – Angular and Vue do
                        varying levels of change detection to automatically keep your code and view in-sync, but React
                        requires the developer to notify it of changes that are worth rendering. This makes it very fast
                        but also requires more work and micromanagement on the part of the implementor. As you move into
                        more advanced React projects you’ll almost certainly end up using management libraries like Flux
                        & Redux to handle more complex change detection and state management situations since it quickly
                        becomes difficult to handle manually.
                        Stylistically, React aims to keep code and view tightly intertwined – the view code is typically
                        written in a mixed markup known as JSX. I personally don’t like interweaving my code that way
                        but I see the advantage and could get used to it given time.
                        An
                        YOU MIGHT LIKE… | YOU MIGHT HATE…
                        Almost pure JavaScript | JSX, some awkward syntax
                        Lightweight | Intermixed View, Style, and Logic code
                        Brevity | State management


                        JSX implies that everything in React is Javascript — it is used for both the JSX templates and
                        the logic.
                    </div>
                </div>
                <div class="col_text">
                    <div data-markdown>
                        ![Img](/img/1280px-React-icon.svg-2.png)
                        - 2013 Facebook
                        - ES6 + Babel
                        - View library / JSX
                        - Virtual DOM
                        - one-directional
                        - create-react-app
                        - React Native
                        - 43kb
                    </div>
                </div>
            </div>
        </section>

        <!--VUE-->
        <section>
            <div class="container">
                <div class="col_code">
                    <div data-markdown>
                        ![Img](/img/vue.png)

                        Note:
                        Vue is a relative newcomer. Those coming from Angular and React will see a lot that feels
                        familiar – Vue shares the some of the same directive-based structures as Angular, while code
                        organization is similar to React with intermixed view templates, logic, and styles. It also
                        takes the approach of being a slim, targeted framework so unlike Angular there aren’t many extra
                        modules, but it does keep a lot of the helpful elements like filter/pipe chains, one-time
                        binding, and automatic change detection. The net result is a nicely-rounded framework that’ll do
                        pretty much everything you need it to while being *crazy* fast. Overall, the impression I get of
                        Vue is of an updated and streamlined Angular 1.x which is definitely not a bad thing.
                        Vue is primarily developed by a single individual but has some corporate sponsors to pay the
                        bills
                        Vue features “single-file components”. This seems like a trade-off with regard to the separation
                        of concerns — templates, scripts and styles are in one file but in three different, ordered
                        sections.
                        “Intuitive, Fast and Composable MVVM for building interactive interfaces.”
                        made by ex-Google-employee Evan You with sponsors
                        - one-way and two-way data binding
                        GitLAb, GitHub
                        YOU MIGHT LIKE… YOU MIGHT HATE…
                        Half-intermixed View, Style, and Logic code | Half-intermixed View, Style, and Logic code
                        Lightweight | Unintuitive attribute binding
                        Framework support for filters, computed properties, transitions, etc. | IDE support not great
                    </div>
                </div>
                <div class="col_text">
                    <div data-markdown>
                        ![Img](/img/Vue-2.png)
                        - 2014 Evan You
                        - Babel / Buble
                        - Virtual DOM
                        - View library
                        - relatively simple
                        - vue-cli
                        - Weex by Alibaba
                        - 23kb
                    </div>
                </div>
            </div>
        </section>

        <section data-markdown class="sumup">
            <script type="text/template">
                ####  And the winner is ...

                - 🏎 Speed ➡ ***All*** <!-- .element: class="fragment" data-fragment-index="1" -->
                - 👴🏻 Mature ➡ ***Angular / React*** <!-- .element: class="fragment" data-fragment-index="2" -->
                - 📉 Learning curve ➡ ***Vue*** <!-- .element: class="fragment" data-fragment-index="3" -->
                - 💪🏻 Big company behind ➡ ***Angular / React*** <!-- .element: class="fragment" data-fragment-index="4" -->
                - ⭐️ Popularity ➡ ***React*** <!-- .element: class="fragment" data-fragment-index="5" -->
                - 🏠 Startup ➡ ***Vue*** <!-- .element: class="fragment" data-fragment-index="6" -->
                - 🏢 Enterprise ➡ ***Angular / React*** <!-- .element: class="fragment" data-fragment-index="7" -->
                - 📱 Mobile ➡ ***React*** <!-- .element: class="fragment" data-fragment-index="8" -->


                Note:
                many developers prefer Vue for creating small apps.
                React is definitely better for larger apps developing.
                Angular if you don't want to maintain variety of dependencies

                React, Angular and Vue are all pretty cool, and none of them stands clearly above the others.
                Your personal preferences and experience of your team are really the deciding factors.

                Vue uses templates, which makes the development process simpler and faster.
                But when an app is big, these benefits tend to turn into drawbacks.
                React’s code with JS templates is reusable, and when you create React app, you can easily restructure it in future.

                Big company based — Angular/React
                Speed — All. React was built by facebook to handle their huge DOM updates. Angular and Vue are really fast either. so as long as you don’t build a rocket machine with your DOM, all of them are great choice. Facebook is one of the biggest SPA out there.
                Mobile — React. Definitely. after the era of hybrid apps, the world turning right now to a native apps. native apps always been here but you always needed an android developer + ios developer. now with react native you can learn react, then understand the differences between browser elements and mobile elements and you can start build your own native app.
                Angular has NativeScript but it’s not mature/popular as react native.

                And the winner is — REACT!
                Why? i think after everything i said, the most important thing is what will last in the next 5 years.
                So if the past says a big company framework based will live longer, than React/Angular should be the kings here and Vue might be some another framework out there like ember/backbone/knockout was.
                If you have in-house HTML developers who do not want to learn more Javascript, you are better off choosing Angular or Vue. React entails more Javascript (we talk about this later).
            </script>
        </section>

        <section data-markdown class="sumup">
            <script type="text/template">
                ![Img](/img/1280px-React-icon.svg.png)
            </script>
        </section>

        <section>
            <div data-markdown>
                <script type="text/template">
                    ### React Components

                    Note:
                    All logically separable parts of the code, like input field, a button, a form, a list etc. should be written in separate components.
                </script>
            </div>
            <div class="container">
                <div class="col_img">
                    <div data-markdown>
                        ![Img](/img/component.png)
                    </div>
                </div>
                <div class="col_text">
                    <div data-markdown>
                        - reusable
                        - composable
                        - self-contained
                        - unit testable
                    </div>
                </div>
            </div>
        </section>


        <section>
            <section>
                <div data-markdown>
                    <script type="text/template">
                        ### JavaScript XML (JSX)

                        Note:
                        JSX adds an XML-like syntax to JavaScript and makes creating ReactJS components easier.
                        While not required, JSX adds enough benefits to be considered a standard part of React development.
                        JSX provides a shortcut for working with React.createElement() and describes how the UI should render a component.
                        JSX also improves development time
                        JSX also forces safer coding. Before rendering elements, JSX converts everything to strings to escape user inputs and XSS vulnerabilities.
                    </script>
                </div>
                <div class="container">
                    <div class="col_img">
                        <div data-markdown>
                            ![Img](/img/jsx.png)
                        </div>
                    </div>
                    <div class="col_text">
                        <div data-markdown>
                            - create JS objects using HTML syntax
                            - improves development time
                            - forces safer coding
                        </div>
                    </div>
                </div>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### Component with JSX
                    ![Img](/img/jsx2.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### Conditional JSX
                    ![Img](/img/jsx3.png)
                </script>
            </section>
        </section>


        <section>
            <div data-markdown>
                <script type="text/template">
                    ### Component's Properties

                    Note:
                    props are the parameters passed to that function when it's called.
                    Anything can be a prop: a string,boolean, number, some other React element, undefined...
                    The most important thing to keep in mind about the props is that they are read-only, meaning that they can't
                    be changed in the component receiving them and shouldn't be mutated.
                    Props are like parameters - they are passed to a component from the caller of a component (the parent) : as
                    if you called a function with certain parameters.
                </script>
            </div>
            <div class="container">
                <div class="col_img">
                    <div data-markdown>
                        ![Img](/img/props.png)
                    </div>
                </div>
                <div class="col_text">
                    <div data-markdown>
                        - immutable
                        - Uni directional data flow
                    </div>
                </div>
            </div>
        </section>

        <section>
            <section>
                <div data-markdown>
                    <script type="text/template">
                        ### Component's State

                        Note:
                        The state is initialized in the constructor before initial component render
                    </script>
                </div>
                <div class="container">
                    <div class="col_img">
                        <div data-markdown>
                            ![Img](/img/state1.png)
                        </div>
                    </div>
                    <div class="col_text">
                        <div data-markdown>
                            * only for classes
                            * local
                            * mutable
                        </div>
                    </div>
                </div>
            </section>
            <section>
                <div data-markdown>
                    <script type="text/template">
                        ### Component's State p.2

                        Note:
                        Think about what happens when setState() is called.
                        React will first merge the object you passed to setState() into the current state.
                        Then it will start that reconciliation thing.
                        It will create a new React Element tree (an object representation of your UI), diff the new tree against the old tree,
                        figure out what has changed based on the object you passed to setState(), then finally update the DOM.
                        Because of the amount of work involved, calling setState() might not immediately update your state.

                    </script>
                </div>
                <div class="container">
                    <div class="col_img">
                        <div data-markdown>
                            ![Img](/img/state2.png)
                        </div>
                    </div>
                    <div class="col_text">
                        <div data-markdown>
                            * used to handle internal changes
                            * asynchronous
                        </div>
                    </div>
                </div>
            </section>
        </section>

        <section>
            <section data-markdown class="dom">
                <script type="text/template">
                    ### Document Object Model (DOM)
                    * The HTML DOM is always tree-structured
                    * ```getElementById```, ```parentNode``` and ```removeChild``` are methods from HTML DOM API.
                    * Changes to the DOM cause re-rendering of the page.
                    * Operations on DOM are slow

                    ![Img](/img/dom2.png)

                    Note:
                    it's essentially an API for html and xml documents
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ### Virtual DOM

                    * allows to collect several changes to be applied at once.
                    * re-rendering only happens once after a set of changes was applied to the DOM.
                    * is located in memory
                    * avoiding unnecessary changes to the DOM.

                    Note:
                    For web developers, this text is an HTML code, and the DOM is simply called HTML DOM. Elements of HTML become nodes in the DOM.

                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### Virtual DOM vs HTML DOM

                    ![Img](/img/vdom.png)
                </script>
            </section>
            <script type="text/template">


            </script>
        </section>

        <!--LIFECYCLE-->
        <section>
            <section data-markdown>
                <script type="text/template">
                    ### Component Lifecycle

                    ![Img](/img/lifecycle/lifecycle.jpeg)

                    Interactive diagram [here](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

                    Note:
                    Methods handling the component lifecycle are inherited from React.Component
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### constructor
                    ![Img](/img/lifecycle/constructor.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### getDerivedStateFromProps
                    ![Img](/img/lifecycle/getDerived.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### render
                    ![Img](/img/lifecycle/render.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### componentDidMount
                    ![Img](/img/lifecycle/componentDidMount.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### shouldComponentUpdate
                    ![Img](/img/lifecycle/shouldCompUpdate.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### getSnapshotBeforeUpdate
                    ![Img](/img/lifecycle/getSnapshot.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### componentDidUpdate
                    ![Img](/img/lifecycle/compDidUpdate.png)
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### componentWillUnmount
                    ![Img](/img/lifecycle/compWillUnmount.png)
                </script>
            </section>
        </section>

        <!-- LIVECODING -->
        <section data-background-image="/img/cat.gif"></section>

        <!--END-->
        <section data-background-image="/img/thats-all-folks-gif-12.gif"></section>

        <!--LIVE CODING-->
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        controls: true,
        progress: false,
        touch: false,
        slideNumber: false,
        loop: true,
        // defaultTiming:-1,
        // parallaxBackgroundImage: "https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg",
        dependencies: [
            {src: "plugin/markdown/marked.js"},
            {src: "plugin/markdown/markdown.js"},
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: "plugin/notes/notes.js", async: true},
            {
                src: "plugin/highlight/highlight.js", async: true, callback: function () {
                    hljs.initHighlightingOnLoad()
                },
            },
        ],
    })
</script>
</body>
</html>
